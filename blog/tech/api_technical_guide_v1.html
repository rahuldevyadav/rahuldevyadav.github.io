<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APIs Demystified: A Python Developer's Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            opacity: 0.3;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }
        
        .toc {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin: 30px 0;
            border-left: 5px solid #667eea;
        }
        
        .toc h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        .toc ul {
            list-style: none;
        }
        
        .toc li {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .toc li::before {
            content: '‚Üí';
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
        }
        
        .toc a {
            text-decoration: none;
            color: #34495e;
            transition: color 0.3s ease;
        }
        
        .toc a:hover {
            color: #667eea;
        }
        
        .section {
            margin: 40px 0;
            padding: 30px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
        }
        
        .section h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            position: relative;
        }
        
        .section h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
            position: relative;
            padding-left: 20px;
        }
        
        .section h3::before {
            content: '‚ñ∂';
            position: absolute;
            left: 0;
            color: #667eea;
            font-size: 0.8em;
        }
        
        .diagram {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .diagram::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 49%, rgba(102, 126, 234, 0.05) 50%, transparent 51%);
            pointer-events: none;
        }
        
        .api-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            position: relative;
            z-index: 1;
        }
        
        .api-component {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            min-width: 150px;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            transform: translateY(0);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .api-component:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
        }
        
        .arrow {
            font-size: 2em;
            color: #667eea;
            font-weight: bold;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .comparison-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 18px;
            text-align: left;
            font-weight: 600;
        }
        
        .comparison-table td {
            padding: 15px 18px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .comparison-table tr:hover {
            background: #f8f9fa;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow-x: auto;
            border-left: 5px solid #667eea;
            position: relative;
        }
        
        .code-block::before {
            content: 'Python';
            position: absolute;
            top: 10px;
            right: 15px;
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .use-case {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 5px solid #28a745;
        }
        
        .use-case h4 {
            color: #155724;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .api-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .api-type-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .api-type-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .api-type-card:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .api-type-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-left: 0;
        }
        
        .api-type-card h3::before {
            display: none;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pros, .cons {
            padding: 20px;
            border-radius: 12px;
        }
        
        .pros {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border-left: 5px solid #28a745;
        }
        
        .cons {
            background: linear-gradient(135deg, #f8d7da 0%, #f1b0b7 100%);
            border-left: 5px solid #dc3545;
        }
        
        .pros h4, .cons h4 {
            margin-bottom: 12px;
            font-size: 1.1em;
        }
        
        .pros h4 {
            color: #155724;
        }
        
        .cons h4 {
            color: #721c24;
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid #ffc107;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            position: relative;
        }
        
        .highlight-box::before {
            content: 'üí°';
            position: absolute;
            top: -10px;
            left: 20px;
            background: #ffc107;
            padding: 5px 10px;
            border-radius: 50%;
            font-size: 1.2em;
        }
        
        .highlight-box h4 {
            color: #856404;
            margin: 10px 0;
            padding-left: 20px;
        }
        
        @media (max-width: 768px) {
            .api-flow {
                flex-direction: column;
            }
            
            .arrow {
                transform: rotate(90deg);
            }
            
            .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>APIs Demystified: A Python Developer's Complete Guide</h1>
            <p>Types, Use Cases, and Implementation Patterns for Data-Driven Applications</p>
        </div>
        
        <div class="toc">
            <h2>üìã Table of Contents</h2>
            <ul>
                <li><a href="#introduction">1. Introduction to APIs</a></li>
                <li><a href="#fundamentals">2. API Fundamentals</a></li>
                <li><a href="#types">3. Types of APIs</a></li>
                <li><a href="#protocols">4. API Protocols & Standards</a></li>
                <li><a href="#use-cases">5. Use Cases for Python & Data Science</a></li>
                <li><a href="#comparison">6. Detailed Comparison</a></li>
                <li><a href="#implementation">7. Python Implementation Examples</a></li>
                <li><a href="#best-practices">8. Best Practices</a></li>
                <li><a href="#conclusion">9. Conclusion</a></li>
            </ul>
        </div>
        
        <div id="introduction" class="section">
            <h2>1. Introduction to APIs</h2>
            <p>Application Programming Interfaces (APIs) serve as the backbone of modern software architecture, enabling seamless communication between different systems, applications, and services. For Python programmers and data scientists, understanding APIs is crucial for building scalable applications, accessing external data sources, and creating robust data pipelines.</p>
            
            <div class="highlight-box">
                <h4>Key Insight</h4>
                <p>APIs are contracts that define how software components should interact. They abstract complexity while providing standardized access to functionality and data.</p>
            </div>
            
            <div class="diagram">
                <h3>API Communication Flow</h3>
                <div class="api-flow">
                    <div class="api-component">
                        <strong>Client Application</strong><br>
                        (Python Script/App)
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="api-component">
                        <strong>API Gateway</strong><br>
                        (Request Handler)
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="api-component">
                        <strong>Backend Service</strong><br>
                        (Data/Logic Layer)
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="api-component">
                        <strong>Response</strong><br>
                        (JSON/XML Data)
                    </div>
                </div>
            </div>
        </div>
        
        <div id="fundamentals" class="section">
            <h2>2. API Fundamentals</h2>
            
            <h3>Core Components</h3>
            <div class="api-type-grid">
                <div class="api-type-card">
                    <h3>üîó Endpoints</h3>
                    <p>Specific URLs where APIs can be accessed. They define the entry points for different functionalities.</p>
                    <div class="code-block">
https://api.example.com/v1/users
https://api.example.com/v1/data/analytics
                    </div>
                </div>
                
                <div class="api-type-card">
                    <h3>üìã Methods</h3>
                    <p>HTTP verbs that specify the action to be performed on the resource.</p>
                    <ul style="margin-top: 15px;">
                        <li><strong>GET:</strong> Retrieve data</li>
                        <li><strong>POST:</strong> Create new resource</li>
                        <li><strong>PUT:</strong> Update entire resource</li>
                        <li><strong>PATCH:</strong> Partial update</li>
                        <li><strong>DELETE:</strong> Remove resource</li>
                    </ul>
                </div>
                
                <div class="api-type-card">
                    <h3>üîë Authentication</h3>
                    <p>Security mechanisms to verify and authorize API access.</p>
                    <ul style="margin-top: 15px;">
                        <li>API Keys</li>
                        <li>OAuth 2.0</li>
                        <li>JWT Tokens</li>
                        <li>Basic Authentication</li>
                    </ul>
                </div>
                
                <div class="api-type-card">
                    <h3>üìä Response Formats</h3>
                    <p>Standard data formats for API responses.</p>
                    <ul style="margin-top: 15px;">
                        <li><strong>JSON:</strong> Most common, lightweight</li>
                        <li><strong>XML:</strong> Structured, verbose</li>
                        <li><strong>CSV:</strong> Tabular data</li>
                        <li><strong>Binary:</strong> Files, images</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div id="types" class="section">
            <h2>3. Types of APIs</h2>
            
            <div class="api-type-grid">
                <div class="api-type-card">
                    <h3>üåê Web APIs (HTTP/REST)</h3>
                    <p>Most common type, using HTTP protocol for communication over the internet.</p>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>‚úÖ Pros</h4>
                            <ul>
                                <li>Stateless and scalable</li>
                                <li>Language agnostic</li>
                                <li>Cacheable responses</li>
                                <li>Wide tool support</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>‚ùå Cons</h4>
                            <ul>
                                <li>Over-fetching data</li>
                                <li>Multiple requests needed</li>
                                <li>Limited real-time capabilities</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="code-block">
import requests

# GET request example
response = requests.get('https://api.github.com/users/octocat')
user_data = response.json()
print(f"User: {user_data['name']}")
                    </div>
                </div>
                
                <div class="api-type-card">
                    <h3>üéØ GraphQL APIs</h3>
                    <p>Query language for APIs that allows clients to request exactly the data they need.</p>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>‚úÖ Pros</h4>
                            <ul>
                                <li>Single endpoint</li>
                                <li>Flexible data fetching</li>
                                <li>Strong type system</li>
                                <li>Real-time subscriptions</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>‚ùå Cons</h4>
                            <ul>
                                <li>Learning curve</li>
                                <li>Complex caching</li>
                                <li>Query complexity issues</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="code-block">
from gql import gql, Client
from gql.transport.aiohttp import AIOHTTPTransport

# GraphQL query example
query = gql("""
    query GetUser($id: ID!) {
        user(id: $id) {
            name
            email
            posts {
                title
                content
            }
        }
    }
""")

transport = AIOHTTPTransport(url="https://api.example.com/graphql")
client = Client(transport=transport)
result = client.execute(query, variable_values={"id": "123"})
                    </div>
                </div>
                
                <div class="api-type-card">
                    <h3>‚ö° WebSocket APIs</h3>
                    <p>Real-time, bidirectional communication between client and server.</p>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>‚úÖ Pros</h4>
                            <ul>
                                <li>Real-time data streaming</li>
                                <li>Low latency</li>
                                <li>Bidirectional communication</li>
                                <li>Efficient for live updates</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>‚ùå Cons</h4>
                            <ul>
                                <li>Complex state management</li>
                                <li>Connection handling overhead</li>
                                <li>Proxy/firewall issues</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="code-block">
import websocket
import json

def on_message(ws, message):
    data = json.loads(message)
    print(f"Received: {data}")

def on_open(ws):
    ws.send(json.dumps({"subscribe": "crypto_prices"}))

# WebSocket connection
ws = websocket.WebSocketApp("wss://api.example.com/stream",
                          on_message=on_message,
                          on_open=on_open)
ws.run_forever()
                    </div>
                </div>
                
                <div class="api-type-card">
                    <h3>üì° RPC APIs (gRPC)</h3>
                    <p>High-performance, language-agnostic remote procedure call framework.</p>
                    
                    <div class="pros-cons">
                        <div class="pros">
                            <h4>‚úÖ Pros</h4>
                            <ul>
                                <li>High performance</li>
                                <li>Type-safe contracts</li>
                                <li>Streaming support</li>
                                <li>Code generation</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>‚ùå Cons</h4>
                            <ul>
                                <li>HTTP/2 requirement</li>
                                <li>Limited browser support</li>
                                <li>Binary format complexity</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="code-block">
import grpc
from proto import data_service_pb2, data_service_pb2_grpc

# gRPC client example
with grpc.insecure_channel('localhost:50051') as channel:
    stub = data_service_pb2_grpc.DataServiceStub(channel)
    
    request = data_service_pb2.DataRequest(
        query="SELECT * FROM users",
        limit=100
    )
    
    response = stub.GetData(request)
    print(f"Received {len(response.records)} records")
                    </div>
                </div>
            </div>
        </div>
        
        <div id="protocols" class="section">
            <h2>4. API Protocols & Standards</h2>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Protocol</th>
                        <th>Transport</th>
                        <th>Data Format</th>
                        <th>Use Cases</th>
                        <th>Performance</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>REST</strong></td>
                        <td>HTTP/HTTPS</td>
                        <td>JSON, XML</td>
                        <td>Web services, CRUD operations</td>
                        <td>Good</td>
                    </tr>
                    <tr>
                        <td><strong>GraphQL</strong></td>
                        <td>HTTP/HTTPS</td>
                        <td>JSON</td>
                        <td>Flexible data fetching</td>
                        <td>Excellent</td>
                    </tr>
                    <tr>
                        <td><strong>gRPC</strong></td>
                        <td>HTTP/2</td>
                        <td>Protocol Buffers</td>
                        <td>Microservices, high-performance</td>
                        <td>Excellent</td>
                    </tr>
                    <tr>
                        <td><strong>WebSocket</strong></td>
                        <td>TCP</td>
                        <td>Text/Binary</td>
                        <td>Real-time applications</td>
                        <td>Excellent</td>
                    </tr>
                    <tr>
                        <td><strong>SOAP</strong></td>
                        <td>HTTP/HTTPS</td>
                        <td>XML</td>
                        <td>Enterprise, security-critical</td>
                        <td>Fair</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div id="use-cases" class="section">
            <h2>5. Use Cases for Python & Data Science</h2>
            
            <h3>Data Collection & Integration</h3>
            <div class="use-case">
                <h4>üìà Financial Data APIs</h4>
                <p>Integrate stock market data, cryptocurrency prices, and economic indicators for financial analysis and algorithmic trading strategies.</p>
                <div class="code-block">
import yfinance as yf
import pandas as pd

# Fetch stock data
ticker = yf.Ticker("AAPL")
stock_data = ticker.history(period="1y")

# API-like data fetching for analysis
def get_financial_metrics(symbol):
    stock = yf.Ticker(symbol)
    info = stock.info
    return {
        'market_cap': info.get('marketCap'),
        'pe_ratio': info.get('trailingPE'),
        'dividend_yield': info.get('dividendYield')
    }
                </div>
            </div>
            
            <div class="use-case">
                <h4>üå¶Ô∏è Weather & Environmental Data</h4>
                <p>Access meteorological data for climate research, agricultural modeling, and environmental monitoring applications.</p>
                <div class="code-block">
import requests
import pandas as pd

def get_weather_data(city, api_key):
    base_url = "http://api.openweathermap.org/data/2.5/weather"
    params = {
        'q': city,
        'appid': api_key,
        'units': 'metric'
    }
    
    response = requests.get(base_url, params=params)
    data = response.json()
    
    return {
        'temperature': data['main']['temp'],
        'humidity': data['main']['humidity'],
        'pressure': data['main']['pressure']
    }
                </div>
            </div>
            
            <h3>Machine Learning & AI</h3>
            <div class="use-case">
                <h4>ü§ñ ML Model Serving</h4>
                <p>Deploy machine learning models as APIs for real-time predictions and batch processing in production environments.</p>
                <div class="code-block">
from flask import Flask, request, jsonify
import joblib
import numpy as np

app = Flask(__name__)
model = joblib.load('trained_model.pkl')

@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.json
        features = np.array(data['features']).reshape(1, -1)
        prediction = model.predict(features)
        
        return jsonify({
            'prediction': prediction.tolist(),
            'confidence': float(model.predict_proba(features).max())
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 400

if __name__ == '__main__':
    app.run(debug=True)
                </div>
            </div>
            
            <div class="use-case">
                <h4>üî§ NLP & Text Processing</h4>
                <p>Integrate natural language processing services for sentiment analysis, translation, and text generation in data pipelines.</p>
                <div class="code-block">
import openai
from textblob import TextBlob

class TextAnalysisAPI:
    def __init__(self, openai_key):
        openai.api_key = openai_key
    
    def analyze_sentiment(self, text):
        blob = TextBlob(text)
        return {
            'polarity': blob.sentiment.polarity,
            'subjectivity': blob.sentiment.subjectivity
        }
    
    def generate_summary(self, text):
        response = openai.Completion.create(
            engine="text-davinci-003",
            prompt=f"Summarize this text: {text}",
            max_tokens=150
        )
        return response.choices[0].text.strip()
                </div>
            </div>
            
            <h3>Data Pipeline & ETL</h3>
            <div class="use-case">
                <h4>üîÑ Database Integration</h4>
                <p>Create APIs for database operations, enabling secure and controlled access to data stores in ETL processes.</p>
                <div class="code-block">
import psycopg2
from sqlalchemy import create_engine
import pandas as pd

class DatabaseAPI:
    def __init__(self, connection_string):
        self.engine = create_engine(connection_string)
    
    def execute_query(self, query, params=None):
        try:
            df = pd.read_sql_query(query, self.engine, params=params)
            return {
                'data': df.to_dict('records'),
                'row_count': len(df),
                'columns': df.columns.tolist()
            }
        except Exception as e:
            return {'error': str(e)}
    
    def bulk_insert(self, table_name, data_df):
        try:
            rows_inserted = data_df.to_sql(
                table_name, 
                self.engine, 
                if_exists='append', 
                index=False
            )
            return {'status': 'success', 'rows_inserted': len(data_df)}
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
                </div>
            </div>
            
            <div class="use-case">
                <h4>üìä Real-time Data Streaming</h4>
                <p>Build streaming APIs for real-time analytics, monitoring dashboards, and live data visualization applications.</p>
                <div class="code-block">
import asyncio
import websockets
import json
from datetime import datetime
import random

class StreamingDataAPI:
    def __init__(self):
        self.clients = set()
    
    async def register_client(self, websocket):
        self.clients.add(websocket)
        print(f"Client registered: {len(self.clients)} total")
    
    async def unregister_client(self, websocket):
        self.clients.discard(websocket)
        print(f"Client unregistered: {len(self.clients)} total")
    
    async def broadcast_data(self, data):
        if self.clients:
            message = json.dumps({
                'timestamp': datetime.now().isoformat(),
                'data': data
            })
            await asyncio.gather(
                *[client.send(message) for client in self.clients],
                return_exceptions=True
            )
    
    async def generate_sample_data(self):
        while True:
            sample_data = {
                'metric': 'cpu_usage',
                'value': random.uniform(10, 90),
                'server': f'server-{random.randint(1, 5)}'
            }
            await self.broadcast_data(sample_data)
            await asyncio.sleep(1)
                </div>
            </div>
        </div>
        
        <div id="comparison" class="section">
            <h2>6. Detailed Comparison Matrix</h2>
            
            <h3>Performance & Scalability Comparison</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>REST API</th>
                        <th>GraphQL</th>
                        <th>gRPC</th>
                        <th>WebSocket</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Latency</strong></td>
                        <td>Medium (HTTP overhead)</td>
                        <td>Low (single request)</td>
                        <td>Very Low (binary protocol)</td>
                        <td>Very Low (persistent connection)</td>
                    </tr>
                    <tr>
                        <td><strong>Throughput</strong></td>
                        <td>Good</td>
                        <td>Excellent</td>
                        <td>Excellent</td>
                        <td>Excellent</td>
                    </tr>
                    <tr>
                        <td><strong>Caching</strong></td>
                        <td>Native HTTP caching</td>
                        <td>Complex (query-based)</td>
                        <td>Application-level</td>
                        <td>Not applicable</td>
                    </tr>
                    <tr>
                        <td><strong>Bandwidth Usage</strong></td>
                        <td>Medium</td>
                        <td>Low (precise data)</td>
                        <td>Low (binary format)</td>
                        <td>Low (after handshake)</td>
                    </tr>
                    <tr>
                        <td><strong>Real-time Support</strong></td>
                        <td>Limited (polling)</td>
                        <td>Good (subscriptions)</td>
                        <td>Excellent (streaming)</td>
                        <td>Excellent (native)</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Development & Maintenance Comparison</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Factor</th>
                        <th>REST API</th>
                        <th>GraphQL</th>
                        <th>gRPC</th>
                        <th>WebSocket</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Learning Curve</strong></td>
                        <td>Low</td>
                        <td>Medium</td>
                        <td>High</td>
                        <td>Medium</td>
                    </tr>
                    <tr>
                        <td><strong>Tooling Support</strong></td>
                        <td>Excellent</td>
                        <td>Good</td>
                        <td>Good</td>
                        <td>Fair</td>
                    </tr>
                    <tr>
                        <td><strong>Documentation</strong></td>
                        <td>OpenAPI/Swagger</td>
                        <td>Self-documenting schema</td>
                        <td>Protocol Buffer definitions</td>
                        <td>Custom documentation</td>
                    </tr>
                    <tr>
                        <td><strong>Testing Complexity</strong></td>
                        <td>Low</td>
                        <td>Medium</td>
                        <td>Medium</td>
                        <td>High</td>
                    </tr>
                    <tr>
                        <td><strong>Debugging</strong></td>
                        <td>Easy (HTTP tools)</td>
                        <td>Good (GraphQL tools)</td>
                        <td>Moderate (binary format)</td>
                        <td>Challenging</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div id="implementation" class="section">
            <h2>7. Python Implementation Examples</h2>
            
            <h3>Building a Comprehensive Data Science API</h3>
            <div class="code-block">
from flask import Flask, request, jsonify, stream_template
from flask_cors import CORS
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import joblib
import io
import base64
import matplotlib.pyplot as plt
import seaborn as sns

app = Flask(__name__)
CORS(app)

class DataScienceAPI:
    def __init__(self):
        self.models = {}
        self.datasets = {}
    
    def load_dataset(self, name, data):
        """Load and store dataset"""
        try:
            if isinstance(data, str):
                # Assume CSV data
                df = pd.read_csv(io.StringIO(data))
            else:
                df = pd.DataFrame(data)
            
            self.datasets[name] = df
            return {
                'status': 'success',
                'shape': df.shape,
                'columns': df.columns.tolist(),
                'head': df.head().to_dict('records')
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def train_model(self, dataset_name, target_column, model_type='random_forest'):
        """Train ML model on dataset"""
        try:
            if dataset_name not in self.datasets:
                return {'status': 'error', 'message': 'Dataset not found'}
            
            df = self.datasets[dataset_name]
            X = df.drop(columns=[target_column])
            y = df[target_column]
            
            # Handle categorical variables
            X_encoded = pd.get_dummies(X, drop_first=True)
            
            X_train, X_test, y_train, y_test = train_test_split(
                X_encoded, y, test_size=0.2, random_state=42
            )
            
            if model_type == 'random_forest':
                model = RandomForestRegressor(n_estimators=100, random_state=42)
            
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            mse = mean_squared_error(y_test, y_pred)
            
            model_name = f"{dataset_name}_{model_type}_{target_column}"
            self.models[model_name] = {
                'model': model,
                'feature_names': X_encoded.columns.tolist(),
                'target_column': target_column
            }
            
            return {
                'status': 'success',
                'model_name': model_name,
                'mse': float(mse),
                'feature_importance': dict(zip(
                    X_encoded.columns,
                    model.feature_importances_
                ))
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def predict(self, model_name, features):
        """Make predictions using trained model"""
        try:
            if model_name not in self.models:
                return {'status': 'error', 'message': 'Model not found'}
            
            model_info = self.models[model_name]
            model = model_info['model']
            
            # Ensure feature order matches training data
            feature_df = pd.DataFrame([features])
            feature_df = feature_df.reindex(columns=model_info['feature_names'], fill_value=0)
            
            prediction = model.predict(feature_df)
            
            return {
                'status': 'success',
                'prediction': float(prediction[0]),
                'model_name': model_name
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def generate_visualization(self, dataset_name, chart_type, x_column, y_column=None):
        """Generate data visualization"""
        try:
            if dataset_name not in self.datasets:
                return {'status': 'error', 'message': 'Dataset not found'}
            
            df = self.datasets[dataset_name]
            plt.figure(figsize=(10, 6))
            
            if chart_type == 'histogram':
                plt.hist(df[x_column], bins=30, alpha=0.7)
                plt.xlabel(x_column)
                plt.ylabel('Frequency')
                plt.title(f'Distribution of {x_column}')
            
            elif chart_type == 'scatter' and y_column:
                plt.scatter(df[x_column], df[y_column], alpha=0.6)
                plt.xlabel(x_column)
                plt.ylabel(y_column)
                plt.title(f'{x_column} vs {y_column}')
            
            elif chart_type == 'correlation':
                correlation_matrix = df.select_dtypes(include=[np.number]).corr()
                sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
                plt.title('Correlation Matrix')
            
            # Convert plot to base64 string
            buffer = io.BytesIO()
            plt.savefig(buffer, format='png', bbox_inches='tight', dpi=150)
            buffer.seek(0)
            plot_data = base64.b64encode(buffer.getvalue()).decode()
            plt.close()
            
            return {
                'status': 'success',
                'image': f'data:image/png;base64,{plot_data}'
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}

# Initialize API instance
ds_api = DataScienceAPI()

# API Endpoints
@app.route('/api/datasets', methods=['POST'])
def upload_dataset():
    data = request.json
    result = ds_api.load_dataset(data['name'], data['data'])
    return jsonify(result)

@app.route('/api/train', methods=['POST'])
def train_model():
    data = request.json
    result = ds_api.train_model(
        data['dataset_name'],
        data['target_column'],
        data.get('model_type', 'random_forest')
    )
    return jsonify(result)

@app.route('/api/predict', methods=['POST'])
def make_prediction():
    data = request.json
    result = ds_api.predict(data['model_name'], data['features'])
    return jsonify(result)

@app.route('/api/visualize', methods=['POST'])
def create_visualization():
    data = request.json
    result = ds_api.generate_visualization(
        data['dataset_name'],
        data['chart_type'],
        data['x_column'],
        data.get('y_column')
    )
    return jsonify(result)

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({
        'status': 'healthy',
        'datasets': len(ds_api.datasets),
        'models': len(ds_api.models)
    })

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
            </div>
            
            <h3>API Client for Data Scientists</h3>
            <div class="code-block">
import requests
import pandas as pd
import json
from typing import Dict, List, Optional

class DataScienceClient:
    def __init__(self, base_url: str = "http://localhost:5000/api"):
        self.base_url = base_url
        self.session = requests.Session()
    
    def upload_dataset(self, name: str, data: pd.DataFrame) -> Dict:
        """Upload dataset to the API"""
        payload = {
            'name': name,
            'data': data.to_csv(index=False)
        }
        response = self.session.post(f"{self.base_url}/datasets", json=payload)
        return response.json()
    
    def train_model(self, dataset_name: str, target_column: str, 
                   model_type: str = 'random_forest') -> Dict:
        """Train a machine learning model"""
        payload = {
            'dataset_name': dataset_name,
            'target_column': target_column,
            'model_type': model_type
        }
        response = self.session.post(f"{self.base_url}/train", json=payload)
        return response.json()
    
    def predict(self, model_name: str, features: Dict) -> Dict:
        """Make predictions using trained model"""
        payload = {
            'model_name': model_name,
            'features': features
        }
        response = self.session.post(f"{self.base_url}/predict", json=payload)
        return response.json()
    
    def create_visualization(self, dataset_name: str, chart_type: str,
                           x_column: str, y_column: Optional[str] = None) -> Dict:
        """Generate data visualization"""
        payload = {
            'dataset_name': dataset_name,
            'chart_type': chart_type,
            'x_column': x_column
        }
        if y_column:
            payload['y_column'] = y_column
        
        response = self.session.post(f"{self.base_url}/visualize", json=payload)
        return response.json()
    
    def health_check(self) -> Dict:
        """Check API health status"""
        response = self.session.get(f"{self.base_url}/health")
        return response.json()

# Usage example
if __name__ == "__main__":
    # Initialize client
    client = DataScienceClient()
    
    # Create sample dataset
    sample_data = pd.DataFrame({
        'feature1': np.random.randn(1000),
        'feature2': np.random.randn(1000),
        'target': np.random.randn(1000)
    })
    
    # Upload dataset
    upload_result = client.upload_dataset('sample_data', sample_data)
    print("Upload result:", upload_result)
    
    # Train model
    train_result = client.train_model('sample_data', 'target')
    print("Training result:", train_result)
    
    # Make prediction
    prediction_result = client.predict(
        train_result['model_name'],
        {'feature1': 0.5, 'feature2': -0.3}
    )
    print("Prediction result:", prediction_result)
            </div>
        </div>
        
        <div id="best-practices" class="section">
            <h2>8. Best Practices for Python API Development</h2>
            
            <div class="api-type-grid">
                <div class="api-type-card">
                    <h3>üîí Security Best Practices</h3>
                    <ul>
                        <li><strong>Authentication:</strong> Implement proper API key or OAuth 2.0</li>
                        <li><strong>Rate Limiting:</strong> Prevent abuse with request throttling</li>
                        <li><strong>Input Validation:</strong> Sanitize all incoming data</li>
                        <li><strong>HTTPS Only:</strong> Encrypt all API communications</li>
                        <li><strong>Error Handling:</strong> Don't expose sensitive information</li>
                    </ul>
                    
                    <div class="code-block">
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import secrets

# Rate limiting
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["1000 per day", "100 per hour"]
)

@app.route('/api/data')
@limiter.limit("10 per minute")
def get_data():
    # API key validation
    api_key = request.headers.get('X-API-Key')
    if not api_key or not validate_api_key(api_key):
        return jsonify({'error': 'Invalid API key'}), 401
    
    return jsonify({'data': 'secure_data'})
                    </div>
                </div>
                
                <div class="api-type-card">
                    <h3>üìä Performance Optimization</h3>
                    <ul>
                        <li><strong>Caching:</strong> Implement Redis or in-memory caching</li>
                        <li><strong>Pagination:</strong> Limit response sizes</li>
                        <li><strong>Compression:</strong> Use gzip for large responses</li>
                        <li><strong>Database Optimization:</strong> Efficient queries and indexing</li>
                        <li><strong>Async Processing:</strong> Use asyncio for I/O operations</li>
                    </ul>
                    
                    <div class="code-block">
from flask_caching import Cache
import asyncio
import aiohttp

# Caching configuration
app.config['CACHE_TYPE'] = 'redis'
app.config['CACHE_REDIS_URL'] = 'redis://localhost:6379/0'
cache = Cache(app)

@app.route('/api/expensive-operation')
@cache.cached(timeout=300)  # Cache for 5 minutes
def expensive_operation():
    # Expensive computation here
    result = perform_complex_calculation()
    return jsonify(result)

# Async API client
async def fetch_multiple_apis(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        return results
                    </div>
                </div>
                
                <div class="api-type-card">
                    <h3>üìù Documentation & Testing</h3>
                    <ul>
                        <li><strong>OpenAPI/Swagger:</strong> Auto-generate documentation</li>
                        <li><strong>Unit Tests:</strong> Comprehensive test coverage</li>
                        <li><strong>Integration Tests:</strong> Test API endpoints</li>
                        <li><strong>Monitoring:</strong> Log and monitor API usage</li>
                        <li><strong>Versioning:</strong> Maintain backward compatibility</li>
                    </ul>
                    
                    <div class="code-block">
from flask_restx import Api, Resource, fields
import pytest

# API documentation with Flask-RESTX
api = Api(app, doc='/docs/')

# Define models for documentation
user_model = api.model('User', {
    'id': fields.Integer(required=True),
    'name': fields.String(required=True),
    'email': fields.String(required=True)
})

@api.route('/users')
class UserList(Resource):
    @api.marshal_list_with(user_model)
    def get(self):
        """Fetch all users"""
        return get_all_users()

# API Testing
def test_api_endpoint():
    with app.test_client() as client:
        response = client.get('/api/users')
        assert response.status_code == 200
        assert 'users' in response.json
                    </div>
                </div>
                
                <div class="api-type-card">
                    <h3>üîÑ Error Handling & Logging</h3>
                    <ul>
                        <li><strong>Consistent Errors:</strong> Standardized error responses</li>
                        <li><strong>HTTP Status Codes:</strong> Use appropriate codes</li>
                        <li><strong>Detailed Logging:</strong> Track API usage and errors</li>
                        <li><strong>Graceful Degradation:</strong> Handle service failures</li>
                        <li><strong>Circuit Breakers:</strong> Prevent cascade failures</li>
                    </ul>
                    
                    <div class="code-block">
import logging
from functools import wraps

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def handle_exceptions(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except ValidationError as e:
            logger.warning(f"Validation error: {str(e)}")
            return jsonify({
                'error': 'Validation Error',
                'message': str(e),
                'code': 'VALIDATION_ERROR'
            }), 400
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}")
            return jsonify({
                'error': 'Internal Server Error',
                'code': 'INTERNAL_ERROR'
            }), 500
    return decorated_function

@app.route('/api/process')
@handle_exceptions
def process_data():
    # Processing logic here
    pass
                    </div>
                </div>
            </div>
        </div>
        
        <div id="conclusion" class="section">
            <h2>9. Conclusion & Future Trends</h2>
            
            <div class="highlight-box">
                <h4>Key Takeaways for Python Developers</h4>
                <p>APIs are fundamental to modern data science and software development. Understanding different API types, protocols, and implementation patterns enables you to build scalable, maintainable systems that can integrate with diverse data sources and services.</p>
            </div>
            
            <h3>Emerging Trends in API Development</h3>
            <div class="api-type-grid">
                <div class="api-type-card">
                    <h3>ü§ñ AI-Powered APIs</h3>
                    <p>Integration of machine learning models directly into API endpoints, enabling real-time inference and intelligent data processing.</p>
                </div>
                
                <div class="api-type-card">
                    <h3>üîÑ Event-Driven Architecture</h3>
                    <p>APIs that react to events and stream data in real-time, supporting modern reactive applications and microservices.</p>
                </div>
                
                <div class="api-type-card">
                    <h3>üõ°Ô∏è Zero-Trust Security</h3>
                    <p>Advanced authentication and authorization mechanisms that assume no implicit trust within the network perimeter.</p>
                </div>
                
                <div class="api-type-card">
                    <h3>üìä API Analytics</h3>
                    <p>Comprehensive monitoring, usage analytics, and performance optimization tools for API management and governance.</p>
                </div>
            </div>
            
            <h3>Recommended Learning Path</h3>
            <ol style="margin: 20px 0; padding-left: 20px;">
                <li><strong>Master REST fundamentals</strong> - Start with Flask/FastAPI</li>
                <li><strong>Explore GraphQL</strong> - Learn flexible data querying</li>
                <li><strong>Understand WebSocket</strong> - Real-time applications</li>
                <li><strong>Practice with real APIs</strong> - Twitter, GitHub, financial data</li>
                <li><strong>Build production APIs</strong> - Security, monitoring, scaling</li>
                <li><strong>Experiment with gRPC</strong> - High-performance scenarios</li>
            </ol>
            
            <div class="use-case">
                <h4>üöÄ Next Steps</h4>
                <p>Start building your own APIs using the examples and patterns shown in this guide. Practice with real datasets, implement proper security measures, and focus on creating APIs that solve actual problems in your domain. The future of data science increasingly depends on well-designed APIs that can scale and integrate seamlessly with other systems.</p>
            </div>
        </div>
        
        <div style="text-align: center; margin: 40px 0; padding: 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 15px;">
            <h3>Happy API Building! üöÄ</h3>
            <p>Remember: Great APIs are not just about the technology‚Äîthey're about creating seamless experiences for developers and users.</p>
        </div>
    </div>
</body>
</html>
            